8-26

B521

Dan Friedman

================================================================================

Scheme:
  - car
  - cdr
  - cons
  - null?
  - length

  - arithmetic: (- n1 n2) is monus, (sub1 n) = n - 1 if n > 0 else 0

================================================================================

Sets:
  - disallow repeated elements
  - support membership testing
  (define member?
    (lambda (a set)
      (cond
       ((null? set) #f)
       ((eqv? a (car set)) #t)
       (else (member? a (cdr set))))))
  (define rember
    (lambda (a l)
      (cond
       ((null? l) '())
       ((eqv? a (car l)) (cdr l))
       (else (cons (car l) (rember a (cdr l)))))))
  (define plus
    (lambda (n1 n2)
      (cond
       ((zero? n2) n1)
       (else (add1 (plus n1 (sub1 n2)))))))
  (define mult
    (lambda (n1 n2)
      (cond
       ((zero? n2) 0)
       (else (plus n1 (mult n1 (sub1 n2)))))))

================================================================================

8-28

(define rember
    (lambda (a l)
      (cond
       ((null? l) '())
       ((eqv? (car l) a) (rember a (cdr l)))
       (else (cons (car l) (rember a (cdr l)))))))

(define rember*
    (lambda (a l)
      (cond
       ((null? l) '())
       ((pair? (car l)) (cons (rember* a (car l)) (rember* a (cdr l))))
       ((eqv? (car l) a) (rember* a (cdr l)))
       (else (cons (car l) (rember* a (cdr l)))))))

(define all-bool?
    (lambda (l)
      (cond
       ((null? l) #t)
       ((pair? (car l)) (and (all-bool? (car l)) (all-bool? (cdr l))))
       ((boolean? (car l)) (all-bool? (cdr l)))
       (else #f))))

- Complicated data structures don't require complicated functions

================================================================================

(define plus
  (lambda (n1 n2)
    (cond
     ((zero? n2) n1)
     (else (add1 (plus n1 (sub1 n2)))))))

(define mult
    (lambda (n1 n2)
      (cond
       ((zero? n2) 0)
       (else (plus n1 (mult n1 (sub1 n2)))))))

(define arrow
    (lambda (n1 n2)
      (cond
       ((zero? n2) 1)
       (else (mult n1 (arrow n1 (sub1 n2)))))))

(define double-arrow
    (lambda (n1 n2)
      (cond
       ((zero? n2) 1)
       (else (arrow n1 (double-arrow n1 (sub1 n2)))))))

(define triple-arrow
    (lambda (n1 n2)
      (cond
       ((zero? n2) 1)
       (else (double-arrow n1 (triple-arrow n1 (sub1 n2)))))))

(define G
    (lambda (i)
      (lambda (n1 n2)
        (cond
         ((zero? i) (cond
                     ((zero? n2) n1)
                     (else (add1 ((G 0) n1 (sub1 n2))))))
         ((eqv? i 1) (cond
                      ((zero? n2) 0)
                      (else ((G (sub1 i)) n1 ((G i) n1 (sub1 n2))))))
         (else (cond
                ((zero? n2) 1)
                (else ((G (sub1 i)) n1 ((G i) n1 (sub1 n2))))))))))

(define GG
    (lambda (i)
      (lambda (n1 n2)
        (cond
         ((zero? i) (cond
                     ((zero? n2) n1)
                     (else (add1 ((GG 0) n1 (sub1 n2))))))
         ((eqv? i 1) (cond
                      ((zero? n2) 0)
                      (else ((GG (sub1 i)) n1 ((GG i) n1 (sub1 n2))))))
         (else (cond
                ((zero? n2) 1)
                (else ((GG (sub1 i)) n1 ((GG i) n1 (sub1 n2))))))))))

- ... correctness-preserving transformations ...

(define GG
    (lambda (i n1 n2)
      (cond
       ((and (zero? n2) (zero? i)) n1)
       ((and (zero? n2) (zero? (sub1 i))) 0)
       ((zero? n2) 1)
       ((zero? i) (add1 (GG i n1 (sub1 n2))))
       (else (GG (sub1 i) n1 (GG i n1 (sub1 n2)))))))

(define ackerman GG) ;; yep!

================================================================================

9-2

- Our language is the lambda calculus.
  - (lambda (x) body) : lambda term
  - (M_1 M_2) : application
  - x : variable

- pmatch! pattern matching
  - ` : quasiquote
  - ' : quote
  - , : unquote
  - > `(mary had a little lamb)
      '(mary had a little lamb)
  - > (let ((name 'mary))
        `(,name had a little lamb))
      '(mary had a little lamb)
  - unquote evaluates expressions

(define -length
  (lambda (l)
    (pmatch l
      (`(,a . ,d) (+ 1 (-length d)))
      (else 0))))

(define cons-cell-count
  (lambda (tr)
    (pmatch tr
      (`(,a . ,d) (+ 1 (cons-cell-count a) (cons-cell-count d)))
      (else 0))))

(define stuff
  (lambda (e)
    (pmatch e
      (`,x (guard (symbol? x)) 'foo)
      (`(lambda (,x) ,body) 'foo)
      (`(,rator ,rand) 'foo))))

================================================================================

9-4

(define assv
  (lambda (x al)
    (pmatch al
      (`() #f)
      (`(,A . ,D)
       (cond
        ((eqv? (car A) x) A)
        (else (assv x D)))))))

- De Bruijn indices

(define map-alist ;; maybe useful?
  (lambda (f al)
    (pmatch al
      (`() '())
      (`(,A . ,D) (cons (cons (car A) (f (cdr A))) (map-alist f D))))))

(define var-occurs-free?
  (lambda (x e cenv)
    (pmatch-who "vof?" e
      (`,y (guard (symbol? y)) (and (eqv? y x) (not (memv x cenv))))
      (`(lambda (,y) ,body) (var-occurs-free? x body (cons y cenv)))
      (`(,rator ,rand) (or (var-occurs-free? x rator cenv)
                           (var-occurs-free? x rand cenv))))))

(define var-occurs-bound?
  (lambda (x e cenv)
    (pmatch-who "vob?" e
      (`,y (guard (symbol? y)) (and (eqv? y x) (memv x cenv)))
      (`(lambda (,y) ,body) (var-occurs-bound? x body (cons y cenv)))
      (`(,rator ,rand) (or (var-occurs-bound? x rator cenv)
                           (var-occurs-bound? x rand cenv))))))

================================================================================

9-9

- The lambda calculus!

(define valof
  (lambda (exp env)
    (pmatch exp
      (`,n (guard (number? n)) n)
      (`,x (guard (symbol? x)) (env x))
      (`(lambda (,x) ,body) (lambda (a) (valof body (lambda (y) (if (eqv? y x) a (env y))))))
      (`(zero? ,n-exp) (zero? (valof n-exp env)))
      (`(,rator ,rand) ((valof rator env) (valof rand env))))))

================================================================================

- Representation independence in interpreters

(define valof
  (lambda (exp env)
    (pmatch exp
      (`,x (guard (symbol? x)) (apply-env env x))
      (`(lambda (,x) ,body) (lambda (a) (valof body (extend-env x a env))))
      (`(,rator ,rand) ((valof rator env) (valof rand env))))))

(define extend-env
  (lambda (x a env)
     (lambda (y) (if (eqv? x y) a (apply-env env y)))))

(define empty-env
  (lambda ()
    (lambda (y)
      (error "empty environment"))))

(define apply-env
  (lambda (env x)
    (env x)))

- Or we can write:

(define apply-env
  (lambda (env x)
    (pmatch env
      (`(empty-env) (error "empty environment"))
      (`(extend-env ,x ,a ,env) (if (eqv? x y)
                                    a
                                    (apply-env env x))))))

(define extend-env
  (lambda (x a env)
    `(extend-env ,x ,a ,env)))

(define empty-env
  (lambda ()
    '(empty-env)))

- So we have two different representations for the same problem --
  valof doesn't care which environment type we have.

- With abstraction over closures:

(define valof
  (lambda (exp env)
    (pmatch exp
      (`,x (guard (symbol? x)) (apply-env env x))
      (`(lambda (,x) ,body) (closure x body env))
      (`(,rator ,rand) (apply-closure (valof rator env) (valof rand env))))))

(define closure
  (lambda (x body env)
    (lambda (a)
      (valof body (extend-env x a env)))))

(define apply-closure
  (lambda (p a)
    (p a)))

-- Or:

(define closure
  (lambda (x body env)
    `(closure ,x ,body ,env)))

(define apply-closure
  (lambda (p a)
    (pmatch p
      (`(closure ,x ,body ,env) (valof body (extend-env x a env))))))

- Recursion with omega combinator:
  ((lambda (f) (f f))
   (lambda (f) (f f)))

- Recursion with Y!
(define Y
  (lambda (f)
    ((lambda (x) (x x))
     (lambda (x) (f (lambda (y) ((x x) y)))))))

(define fac
  (lambda (recur)
    (lambda (n)
      (if (zero? n)
          1
          (* n (recur (sub1 n)))))))

================================================================================

9-16

- Dynamic and lexical scope

> (let ((a 1))
>   (let ((whats-a? (lambda (_) a)))
>     (let ((a 2))
>       (whats-a? 0))))

- In Racket, returns 1
- In elisp (with `(funcall whats-a? 0)`), returns 2

- `dlambda` gives dynamic scope, `lambda` lexical scope:
> (define valof
>   (lambda (e env)
>     (pmatch e
>       (`,x (guard (symbol? x)) (env x))
>       (`(lambda (,x) ,body) (lambda (a env) (valof body (lambda (y)
>                                                           (if (eqv? y x)
>                                                               a
>                                                               (env y))))))
>       (`(dlambda (,x) ,body) (lambda (a env^) (valof body (lambda (y)
>                                                             (if (eqv? y x)
>                                                                 a
>                                                                 (env^ y))))))
>       (`(,rator ,rand) ((valof rator env) (valof rand env) env)))))

================================================================================

9-18

- Boxes

> (let ((x 5))
    (box x))
> (set-box! a-box 120)

- Side effects in the language -- set!

> (define valof-mut
>   (lambda (exp env)
>     (pmatch exp
>       (`,x (guard (symbol? x)) (unbox (env x)))
>       (`(lambda (,x) ,body) (lambda (a) (valof-mut body (lambda (y)
>                                                       (if (eqv? y x)
>                                                           (box a)
>                                                           (env y))))))
>       (`(,rator ,x) (guard (symbol? x)) ((valof-mut rator env) (box (unbox (env x)))))
>       (`(,rator ,rand) ((valof-mut rator env) (box (valof-mut rand env)))))))

- Laziness (call-by-name, call-by-need)

> (define apply-env
>   (lambda (env x)
>     (env x)))
> 
> (define extend-env
>   (lambda (x a env)
>     (lambda (y)
>       (if (eqv? y x)
>           (box (lambda () a))
>           (apply-env y)))))
> 
> (define valof-name
>   (lambda (exp env)
>     (pmatch exp
>       (`,x (guard (symbol? x)) ((unbox (apply-env env x))))
>       (`(lambda (,x) ,body) (lambda (a) (valof-name body (extend-env x a env))))
>       (`(,rator ,x) (guard (symbol? x)) ((valof-name rator env) (box (unbox (apply-env env x)))))
>       (`(,rator ,rand) ((valof-name rator env) (box (lambda () (valof-name rand env))))))))
> 
> (define valof-need
>   (lambda (exp env)
>     (pmatch exp
>       (`,x (guard (symbol? x)) (let* ((b (apply-env env x))
>                                       (val ((unbox b))))
>                                  (begin (set! b (lambda () val)) val)))
>       (`(lambda (,x) ,body) (lambda (a) (valof-need body (extend-env x a env))))
>       (`(,rator ,x) (guard (symbol? x)) ((valof-need rator env) (box (unbox (apply-env env x)))))
>       (`(,rator ,rand) ((valof-need rator env) (box (lambda () (valof-need rand env))))))))

================================================================================

9-30

- Controlling order of evaluation
  - If (h (f x) (g y)), which of f and g are evaluated first?
  - Make explicit with
  > (let ((a (f x)))
  >   (let ((b (g y)))
  >     (h a b)))
  - A-normal form.
  > (if (h (f x) (g y))
  >     (r s)
  >     (t u))
  - How do we ANF this?
  > (let ((a (f x)))
  >   (let ((b (g y)))
  >     (let ((bool (h a b)))
  >       (if bool
  >           (r s)
  >           (t u)))))
  - All arguments to functions are just variable lookups.
  - CPS
  - Transform original programs to:
  > (f x (lambda (a)
  >        (g y (lambda (b)
  >               (h a b (lambda (x) x))))
  > (f x (lambda (a)
  >        (g y (lambda (b)
  >               (h a b (lambda (bool)
  >                        (if bool
  >                            (r s k)
  >                            (t u k))))))))
  - Factorial
  > (define !
  >   (lambda (n k)
  >     (if (zero? n)
  >         (k 1)
  >         (! (sub1 n) (lambda (m)
  >                       (k (* m n)))))))
  > (define filter-cps
  >   (lambda (p ls k)
  >     (cond
  >      ((null? ls) (k '()))
  >      (else (p (car ls) (lambda (b)
  >                          (if b
  >                              (filter-cps p (cdr ls) (lambda (ls^) (k (cons (car ls) ls^))))
  >                              (filter-cps p (cdr ls) k))))))))
  - Eta expansion: if we have (lambda (a) (f a))
    - f cannot loop,
    - a is a variable,
    - a is not free in f,
    - then we can eta-reduce to f.
  - Alternatively,
  > (define filter-cps^
  >   (lambda (p ls k)
  >     (cond
  >      ((null? ls) (k '()))
  >      (else (p (car ls) (lambda (b)
  >                          (filter-cps^ p (cdr ls) (if b
  >                                                      (lambda (ls^) (k (cons (car ls) ls^)))
  >                                                      k))))))))
